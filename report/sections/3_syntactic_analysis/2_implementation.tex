\subsection{Implementation}

The parser was generated using Gocc from a BNF grammar of the uC language, the listing of which is presented in Appendix~\ref{app:parser/gocc}.

% Construct AST using production actions

\subsubsection{Precedence of Binary Operators}

Precedence of binary operators is implemented in the BNF grammar through a tree-like structure of production rules (actually a graph structure, as nodes may be self-referential and refer to parental nodes), having operators with lower precedence near the root of the tree and operators with higher precedence near the leafs of the tree.

An example of the production rules used to assign a higher precedence to multiplicative operators than additive operators is presented in listing \ref{lst:precedence}.

\begin{lstlisting}[language=go,style=go,caption={\label{lst:precedence}Precedence of binary expressions.}]
// Left-associative binary expressions with precedence 12.
//
//    12L: + -
Expr12L
	: Expr13L
	| Expr12L "+" Expr13L
	| Expr12L "-" Expr13L
;

// Left-associative binary expressions with precedence 13.
//
//    13L: * /
Expr13L
	: Expr14
	| Expr13L "*" Expr14
	| Expr13L "/" Expr14
;
\end{lstlisting}

\subsubsection{Associativity of Binary Operators}

The implementation of left- and right-associativity of binary operators relies on the same tree-like structure as the implementation of operator precedence. The non-terminal node on the right side of a right-associative binary operator (e.g. \texttt{Expr2R} of \texttt{Expr5L ``='' Expr2R}) is self-referential, while the non-terminal node on the left side of the operator (e.g. \texttt{Expr5L} of \texttt{Expr5L ``='' Expr2R}) refers to a node closer to the leaf nodes of the tree. Left-associativity is defined analogously, with a self-referential left side node.

An example of the production rules used to define right-associativity to assignment operators and left-associativity to logical AND operators is presented in listing \ref{lst:associativity}.

\begin{lstlisting}[language=go,style=go,caption={\label{lst:associativity}Associativity of binary expressions.}]
// Right-associative binary expressions with precedence 2.
//
//    2R: =
Expr2R
	: Expr5L
	// Right-associative.
	| Expr5L "=" Expr2R
;

// Left-associative binary expressions with precedence 5.
//
//    5L: &&
Expr5L
	: Expr9L
	| Expr5L "&&" Expr9L
;
\end{lstlisting}

\subsubsection{Syntax Tree Representation}

% You should also describe the representation of syntax trees and list the different kinds of nodes.

foo

\subsubsection{Dangling Else}

% The dangling else problem is the cannonical example of a shift reduce conflict for LR grammars.
%
% It is present in the ÂµC grammar:
%
% 1 LR-1 conflicts:
%     S271
%         symbol: else
%             Shift(277)
%             Reduce(32:ElsePart : empty  <<  >>)
%
% To solve this specific ambiguity, we've decided to use the automatic conflict resolution of Gocc, which always shifts when encountering a shift-reduce conflict, as is the expected resolution for C language grammars.
%
% Below follows an extract from the Gocc user guide on this topic.
%
%     When automatic LR(1) conflict resolution is selected by the -a option, gocc resolves this conflict in the same way as specified in the C language specification: by shifting and parsing the longest valid production (maximal-munch). This means recognising the else-statement as part of the second if.

% Automatic LR(1) conflict resolution (the -a flag) is already used in the parser generation rule of the Makefile. Closing this issue for now.

\footnote{Dangling else: \url{https://github.com/mewmew/uc/issues/31}}

foo

% ----------------------------------------

foo

% From LR1_conflicts.txt generated by Gocc:
%
% LR-1 conflicts:
%     S6
%         symbol: ident
%             Reduce(13:VoidType : ident  <<  >>)
%             Reduce(10:TypeName : ident  <<  >>)
%
% Relevant production rules from the BNF grammar:
%
% TypeName
%     : ident // "char" | "int"
% ;
%
% FuncType
%     : VoidType
%     | TypeName
% ;
%
% VoidType
%     : ident // "void"
% ;

% A potential solution may be to merge VoidType, FuncType and TypeName into the single production rule TypeName : ident ;. Type checking would handle invalid uses of void. This approach was also suggested in the uC language page, which mentions the following:

% "The other alternative is to allow void as an alternative in typename, and to replace funtype with typename. This however means that the grammar accepts variable or array declarations with void as base type: they must be detected and rejected, either by the syntax-tree building code, or by the type checking code. (This solution is required for full C since full C includes variable declarations such as void *ptr.)"

% \footnote{Reduce-reduce conflict between TypeName and VoidType: \url{https://github.com/mewmew/uc/issues/26}}

% ----------------------

% From LR1_conflicts.txt generated by Gocc:
%
% 11 LR-1 conflicts:
%     S28
%         symbol: ident
%             Reduce(19:Locals : empty    <<  >>)
%             Shift(6)
%     S35
%         symbol: ident
%             Reduce(19:Locals : empty    <<  >>)
%             Shift(6)
%
% Relevant production rules from the BNF grammar:
%
% TypeName
%     : ident // TypeName : "char" | "int" | "void" ;
% ;
%
% Locals
%     : empty
%     | VarDecl ";" Locals
% ;

% A potential solution may be to define TypeName as:
%
% TypeName : "char" | "int" | "void" ;
%
% This solves the shift-reduce conflict. The decision may have to be revisited when adding support for user-defined types.

% Another solution may be to remove the Locals production rule and add a DeclStmt production rule for declaration statements to the Stmt production rule. This would allow declaration statements to occur anywhere within blocks, as is valid for later versions of C (with some constraints related to goto, i.e. cannot jump over declaration).
%
% I propose that we remove the Locals production rule and allow declarations to occur anywhere a statement may occur. To enforce uC behaviour we could add a check during the semantic analysis phase which verified that DeclStmts only occur before any other statements within the body of functions.
%
% This would effectively solve the The Hack Issue, as we may revert the TypeName production rule to ident rather than hardcoded "char" | "int" | "void", and as such, this would allow for future extensions with regards to user-defined data types.
%
% Furthermore, we may want to take this approach in the future either way, as our intention is to support a larger and more modern subset of C in the future. Being able to declare variables closer to their initial user is a major win for readability and maintainability of code.

% With commit f7c2633 we are back to using ident for the TypeName production rule, thus handling the Lexer Hack in the same way as Clang. Closing this issue for now. We can easily re-open it later, if after discussion we would prefer to solve this issue in some other way.

% \footnote{Shift-reduce conflict between TypeName and Locals: \url{https://github.com/mewmew/uc/issues/27}}

% -------------------------

% From LR1_conflicts.txt generated by Gocc:
%
%     S105
%         symbol: *
%             Reduce(39:Expr : Expr BinaryOp Expr <<  >>)
%             Shift(70)
%         symbol: /
%             Reduce(39:Expr : Expr BinaryOp Expr <<  >>)
%             Shift(71)
%         symbol: !=
%             Reduce(39:Expr : Expr BinaryOp Expr <<  >>)
%             Shift(76)
%         symbol: &&
%             Reduce(39:Expr : Expr BinaryOp Expr <<  >>)
%             Shift(78)
%         symbol: =
%             Reduce(39:Expr : Expr BinaryOp Expr <<  >>)
%             Shift(79)
%         symbol: ==
%             Reduce(39:Expr : Expr BinaryOp Expr <<  >>)
%             Shift(77)
%         symbol: -
%             Reduce(39:Expr : Expr BinaryOp Expr <<  >>)
%             Shift(68)
%         symbol: +
%             Reduce(39:Expr : Expr BinaryOp Expr <<  >>)
%             Shift(69)
%         symbol: <
%             Shift(72)
%             Reduce(39:Expr : Expr BinaryOp Expr <<  >>)
%         symbol: >
%             Reduce(39:Expr : Expr BinaryOp Expr <<  >>)
%             Shift(73)
%         symbol: <=
%             Shift(74)
%             Reduce(39:Expr : Expr BinaryOp Expr <<  >>)
%         symbol: >=
%             Reduce(39:Expr : Expr BinaryOp Expr <<  >>)
%             Shift(75)
%
% Relevant production rules from the BNF grammar:
%
% Expr
%     : int_lit
%     | ident
%     | ident "[" Expr "]"
%     | UnaryOp Expr
%     | Expr BinaryOp Expr
%     | ident "(" Actuals ")"
%     | "(" Expr ")"
% ;
%
% BinaryOp
%     : "+"
%     | "-"
%     | "*"
%     | "/"
%     | "<"
%     | ">"
%     | "<="
%     | ">="
%     | "!="
%     | "=="
%     | "&&"
%     | "="
% ;

% As of commit 1727d79 the precedence order has been corrected. However, we still need to find a solution for handling left- and right-associativity. The uC language has a single expression which requires right-associativity, namely the assignment expression. For now, finding a solution to this remains an open topic for discussion.

% The parse tree before and after applying commit 2cba9fc, which fixes the right-associativity of assignment expressions.

% \footnote{Associativity and precedence of binary operations: \url{https://github.com/mewmew/uc/issues/29}}
