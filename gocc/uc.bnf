// A grammar for the µC programming language [1].
//
// The content and structure of this document is heavily influenced by the Go
// Programming Language Specification [2] and some parts are therefore governed
// by a BSD-style license [3]. Any original content of this document is hereby
// released into the public domain [4].
//
// References:
//    [1]: https://www.it.uu.se/katalog/aleji304/CompilersProject/uc.html
//    [2]: http://golang.org/ref/spec
//    [3]: http://golang.org/LICENSE
//    [4]: https://creativecommons.org/publicdomain/zero/1.0/

// # Source code representation
//

// ## Characters
//

// An arbitrary ASCII character except null (0x00), new line (0x0A), carriage
// return (0x0D), apostrophe (0x27), double quote (0x22) and backslash (0x5C).
_ascii_char
	: '\x01' - '\x09'
	| '\x0B' - '\x0C'
	| '\x0E' - '\x21'
	| '\x23' - '\x26'
	| '\x28' - '\x5B'
	| '\x5D' - '\x7F'
;

_ascii_letter : 'a' - 'z' | 'A' - 'Z' ;
_ascii_digit  : '0' - '9' ;

// ## Letters and digits
//

_letter        : _ascii_letter | '_' ;
_decimal_digit : _ascii_digit ;
_decimals      : _decimal_digit { _decimal_digit } ;

// # Lexical elements
//

// ## Comments
//

_line_comment
	: '/' '/' { . } '\n'
;

_block_comment : '/' '*' { . | '*' } '*' '/' ;
!comment       : _line_comment | _block_comment ;

// ## Tokens
//

// White space, formed from spaces (0x20), horizontal tabs (0x09), new line
// (line-feed (0x0A) or carriage-return (0x0D)), vertical tabs (0x0B), and form-
// feeds (0x0C) (§6.4), is ignored except as it separates tokens that would
// otherwise combine into a single token.
!whitespace : ' ' | '\t' | '\v' | '\f' | '\r' | '\n' ;

// ## Identifiers
//

ident : _letter { _letter | _decimal_digit } ;

// ## Integer literals
//

int_lit : _decimals | _char_lit ;

// ## Character literals
//

_escaped_char : '\\' 'n' ;
_char_lit     : '\'' ( _ascii_char | '"' | _escaped_char ) '\'' ;


// # Syntaxic production rules
//

<< import (
	"strconv"

	"github.com/mewmew/uc/ast"
	"github.com/mewmew/uc/ast/astx"
	gocctoken "github.com/mewmew/uc/gocc/token"
	"github.com/mewmew/uc/token"
	"github.com/mewmew/uc/types"
) >>

Program
	: TopLevelDeclList
;

TopLevelDeclList
	: empty
	| TopLevelDecl TopLevelDeclList
;

TopLevelDecl
	: VarDecl ";"
	| TypeName ident "(" Formals ")" FuncBody // TypeName : "char" | "int" | "void" ;
;

// TODO: Rename Actuals, Args, and Formals Params.

VarDecl
	: ScalarDecl
	| ArrayDecl
;

ScalarDecl
	: TypeName ident // TypeName : "char" | "int" ;
;

ArrayDecl
	// TypeName : "char" | "int" ;
	: TypeName ident "[" int_lit "]"    << astx.NewArrayDecl($0, $1, $3) >>
;

TypeName
	// TypeName : "char" | "int" | "void" ;
	: "char"                            << &types.Basic{Kind: types.Char}, nil >>
	| "int"                             << &types.Basic{Kind: types.Int}, nil >>
	| "void"                            << &types.Basic{Kind: types.Void}, nil >>
;

FuncBody
	: "{" Locals Stmts "}"
	| ";"
;

Formals
	: TypeName   // TypeName : "void" ;
	| FormalList
;

FormalList
	: FormalDecl
	| FormalDecl "," FormalList
;

FormalDecl
	: ScalarDecl
	// TypeName : "char" | "int" ;
	| TypeName ident "[" "]"
;

Locals
	: empty
	| VarDecl ";" Locals
;

Stmts
	: empty
	| Stmt Stmts
;

Stmt
	: Expr ";"                          << &ast.ExprStmt{X: $0.(ast.Expr)}, nil >>
	| "return" Expr ";"                 << &ast.ReturnStmt{Result: $1.(ast.Expr)}, nil >>
	| "return" ";"                      << &ast.ReturnStmt{}, nil >>
	| "while" Condition Stmt            << &ast.WhileStmt{Cond: $1.(ast.Expr), Body: $2.(ast.Stmt)}, nil >>
	// TODO: Figure out how to handle nil else body. Type assertion will cause panic.
	| "if" Condition Stmt ElsePart      << &ast.IfStmt{Cond: $1.(ast.Expr), Body: $2.(ast.Stmt), Else: $3.(ast.Stmt)}, nil >>
	| "{" Stmts "}"                     << &ast.BlockStmt{Stmts: $1.([]ast.Stmt)}, nil >>
	| ";"                               << &ast.EmptyStmt{}, nil >>
;

ElsePart
	: empty                             << nil, nil >>
	| "else" Stmt                       << $1, nil >>
;

Condition
	: ParenExpr
;

Expr
	: Expr2R
;

// TODO: Figure out how to represent left- and right-associativity. Perhaps this
// may be done during the generation of the AST?

// Right-associative binary expressions with precedence 2.
//
//    2R: =
Expr2R
	: Expr5L
	| Expr2R "=" Expr5L                 << &ast.BinaryExpr{A: $0.(ast.Expr), Op: token.Assign, B: $2.(ast.Expr)}, nil >>
;

// Left-associative binary expressions with precedence 5.
//
//    5L: &&
Expr5L
	: Expr9L
	| Expr5L "&&" Expr9L                << &ast.BinaryExpr{A: $0.(ast.Expr), Op: token.Land, B: $2.(ast.Expr)}, nil >>
;

// Left-associative binary expressions with precedence 9.
//
//    9L: == !=
Expr9L
	: Expr10L
	| Expr9L "==" Expr10L               << &ast.BinaryExpr{A: $0.(ast.Expr), Op: token.Eq, B: $2.(ast.Expr)}, nil >>
	| Expr9L "!=" Expr10L               << &ast.BinaryExpr{A: $0.(ast.Expr), Op: token.Ne, B: $2.(ast.Expr)}, nil >>
;

// Left-associative binary expressions with precedence 10.
//
//    10L: < > <= >=
Expr10L
	: Expr12L
	| Expr10L "<" Expr12L               << &ast.BinaryExpr{A: $0.(ast.Expr), Op: token.Lt, B: $2.(ast.Expr)}, nil >>
	| Expr10L ">" Expr12L               << &ast.BinaryExpr{A: $0.(ast.Expr), Op: token.Gt, B: $2.(ast.Expr)}, nil >>
	| Expr10L "<=" Expr12L              << &ast.BinaryExpr{A: $0.(ast.Expr), Op: token.Le, B: $2.(ast.Expr)}, nil >>
	| Expr10L ">=" Expr12L              << &ast.BinaryExpr{A: $0.(ast.Expr), Op: token.Ge, B: $2.(ast.Expr)}, nil >>
;

// Left-associative binary expressions with precedence 12.
//
//    12L: + -
Expr12L
	: Expr13L
	| Expr12L "+" Expr13L               << &ast.BinaryExpr{A: $0.(ast.Expr), Op: token.Add, B: $2.(ast.Expr)}, nil >>
	| Expr12L "-" Expr13L               << &ast.BinaryExpr{A: $0.(ast.Expr), Op: token.Sub, B: $2.(ast.Expr)}, nil >>
;

// Left-associative binary expressions with precedence 13.
//
//    13L: * /
Expr13L
	: Expr14
	| Expr13L "*" Expr14                << &ast.BinaryExpr{A: $0.(ast.Expr), Op: token.Mul, B: $2.(ast.Expr)}, nil >>
	| Expr13L "/" Expr14                << &ast.BinaryExpr{A: $0.(ast.Expr), Op: token.Div, B: $2.(ast.Expr)}, nil >>
;

// Unary expressions with precedence 14.
//
//    14: - !
Expr14
	: Expr15
	| "-" Expr15                        << &ast.UnaryExpr{Op: token.Sub, B: $1.(ast.Expr)}, nil >>
	| "!" Expr15                        << &ast.UnaryExpr{Op: token.Not, B: $1.(ast.Expr)}, nil >>
;

// TODO: Check that integer litearls, identifiers, index expressions, call
// expressions, and parentesized espressions have precedence 15.

// TODO: Handle char_lit explicitly?

// Expressions with precedence 15.
Expr15
	: int_lit                           << &ast.BasicLit{Kind: token.IntLit, Val: string($2.(*gocctoken.Token).Lit)}, nil >>
	| ident                             << &ast.Ident{Name: string($0.(*gocctoken.Token).Lit)}, nil >>
	| ident "[" Expr "]"                << astx.NewIndexExpr($0, $2) >>
	| ident "(" Actuals ")"             << astx.NewCallExpr($0, $2) >>
	| ParenExpr
;

ParenExpr
	: "(" Expr ")"                      << astx.NewParenExpr($1) >>
;

Actuals
	: empty
	| ExprList
;

ExprList
	: Expr
	| Expr "," ExprList
;
